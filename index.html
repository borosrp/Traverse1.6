<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<title>Traversendaten</title>
<link rel="icon" href='data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><rect fill="white" width="16" height="16"/><g fill="%230056b3"><path d="M1 3h1v10H1z"/><path d="M3 3h2v10H3z"/></g><g fill="black"><path d="M6 3h1v10H6z"/><path d="M8 3h2v10H8z"/><path d="M11 3h1v10h-1z"/><path d="M13 3h2v10h-2z"/></g></svg>'>
<!-- Font Awesome ikonokhoz -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
<style>
    /* Otto Lehmann ihlette design - Maximális 3D hatás */
    :root {
        --bg: #f5f5f5; /* Világosszürke háttér */
        --text: #333333; /* Sötétszürke szöveg */
        --muted: #6c757d; /* Közepes szürke a visszafogott elemekhez */
        --primary: #0056b3; /* Otto Lehmann kékje */
        --primary-dark: #004085; /* Sötétebb kék hoverhez */
        --light-primary: #70A4D5; /* Világoskék a 17-28 kategóriákhoz */
        --light-primary-dark: #5A8FC2; /* Sötétebb világoskék hoverhez */
        --medium-primary: #2C6BB0; /* Új: köztes kék szín, kicsit sötétebb */
        --medium-primary-dark: #23558A; /* Új: sötétebb köztes kék hoverhez */
        --very-light-blue: #E0F2F7; /* ÚJ: Nagyon halványkék az 1-16 kategóriák rácsához */
        --accent: #28a745; /* Professzionális zöld az ékezet/sikerhez */
        --success: #28a745; /* Zöld a sikerüzenetekhez */
        --danger: #dc3545; /* Piros a veszélyhez/törléshez */
        --warning: #ffc107; /* Sárga a figyelmeztetésekhez */
        --border-color: #e0e0e0; /* Világosszürke szegély */
        --card-bg: #ffffff; /* Fehér kártyahátterek */
        --row-alt-bg: #f8f8f8; /* Nagyon világosszürke a váltakozó táblázatsorokhoz */
        
        --shadow-soft: 0 10px 20px rgba(0, 0, 0, 0.25), 0 15px 30px rgba(0, 0, 0, 0.15);
        --shadow-medium: 0 15px 30px rgba(0, 0, 0, 0.35), 0 25px 50px rgba(0, 0, 0, 0.25);
        --shadow-active: 0 3px 6px rgba(0, 0, 0, 0.3), 0 6px 12px rgba(0, 0, 0, 0.2);
    }

    html, body {
        height: 100%;
        margin: 0;
        padding: 0;
    }

    body {
        font-family: 'Segoe UI', 'Roboto', 'Helvetica Neue', Arial, sans-serif;
        color: var(--text);
        background: var(--bg);
        line-height: 1.6;
        margin: 0;
        display: flex;
        flex-direction: column;
        padding: 0 15px; /* Hozzáadva némi oldalsó margó */
        box-sizing: border-box;
    }
    body.modal-open {
        overflow: hidden; /* Megakadályozza a görgetést, amikor modál van nyitva */
    }

    #main-scrollable-area {
        flex: 1;
        overflow-y: auto;
        padding: 15px 0 160px; /* Megnövelt alsó margó, hogy elférjen az alsó vezérlőpult */
        box-sizing: border-box;
    }

    .grid {
        display: grid;
        gap: 15px;
        margin-bottom: 10px;
        background: var(--card-bg);
        padding: 20px;
        border-radius: 8px;
        box-shadow: var(--shadow-soft);
        border: 1px solid var(--text);
    }
    #categoryGrid2 {
        background: #70A4D5; /* Megtartva a rács hátterét, de a gombok színe most felülírja */
    }
    /* ÚJ SZABÁLY: Nagyon halványkék háttér az 1-16 kategóriák rácsához */
    #categoryGrid1 {
        grid-template-columns: repeat(8, 1fr);
        background: var(--very-light-blue);
    }
    #categoryGrid2 {
        grid-template-columns: repeat(12, 1fr);
    }

    .grid button {
        position: relative;
        padding: 20px 10px;
        font-size: 1.2em;
        border-radius: 6px;
        border: 1px solid var(--text);
        cursor: pointer;
        background: var(--primary); /* Alapértelmezett sötétkék */
        color: #ffffff;
        user-select: none;
        transition: all 0.1s ease;
        box-shadow: 0 10px 20px rgba(0, 0, 0, 0.25), 0 15px 30px rgba(0, 0, 0, 0.15);
        text-shadow: none;
    }
    /* MÓDOSÍTVA: Köztes kék a 17-28-as kategóriagombokhoz, ha van adat */
    #categoryGrid2 button:not(.empty-category) {
        background: var(--medium-primary);
    }
    /* MÓDOSÍTVA: Sötétebb köztes kék hover effekt a 17-28-as kategóriagombokhoz */
    #categoryGrid2 button:not(.empty-category):hover {
        background: var(--medium-primary-dark);
        border-color: var(--medium-primary-dark); /* Frissített border-color hoverre */
        box-shadow: 0 15px 30px rgba(0, 0, 0, 0.4), 0 25px 50px rgba(0, 0, 0, 0.3);
    }

    .grid button .time-icon {
        position: absolute;
        bottom: 5px;
        right: 5px;
        font-size: 0.8em;
        text-shadow: 1px 1px 2px rgba(0,0,0,0.5); /* 3D hatás */
    }
    .grid button .day-letter {
        position: absolute;
        bottom: 5px;
        left: 5px;
        font-size: 0.8em;
        font-weight: bold;
        color: white;
        text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
    }
    .grid button.empty-category {
        background: var(--card-bg);
        color: var(--text);
        border-color: var(--text);
        box-shadow: none;
    }
    .grid button:active {
        transform: scale(0.96);
        box-shadow: var(--shadow-active);
    }
    .grid button:hover {
        background: var(--primary-dark);
        box-shadow: var(--shadow-medium);
    }
    .grid button.empty-category:hover {
        background: var(--row-alt-bg);
        border-color: var(--muted);
        box-shadow: none;
    }
    
    @keyframes pulse-primary-dark { /* Átnevezve a tisztaság kedvéért */
        0% { box-shadow: var(--shadow-medium), 0 0 0 0 var(--primary-dark); }
        70% { box-shadow: var(--shadow-medium), 0 0 0 10px rgba(0, 64, 133, 0); } /* Megnövelt szórás, csökkentett intenzitás */
        100% { box-shadow: var(--shadow-medium), 0 0 0 0 var(--primary-dark); }
    }

    @keyframes pulse-light-primary {
        0% { box-shadow: var(--shadow-medium), 0 0 0 0 var(--light-primary); }
        70% { box-shadow: var(--shadow-medium), 0 0 0 10px rgba(112, 164, 213, 0); }
        100% { box-shadow: var(--shadow-medium), 0 0 0 0 var(--light-primary); }
    }

    /* ÚJ ANIMÁCIÓ: Köztes kék pulzálás */
    @keyframes pulse-medium-primary {
        0% { box-shadow: var(--shadow-medium), 0 0 0 0 var(--medium-primary); }
        70% { box-shadow: var(--shadow-medium), 0 0 0 10px rgba(44, 107, 176, 0); } /* Köztes kék árnyék */
        100% { box-shadow: var(--shadow-medium), 0 0 0 0 var(--medium-primary); }
    }

    @keyframes pulse-grey-less-intense { /* Új animáció kevésbé intenzív szürke pulzáláshoz */
        0% { box-shadow: var(--shadow-medium), 0 0 0 0 rgba(108, 117, 125, 0.7); }
        70% { box-shadow: var(--shadow-medium), 0 0 0 10px rgba(108, 117, 125, 0); } /* Megnövelt szórás, csökkentett intenzitás */
        100% { box-shadow: var(--shadow-medium), 0 0 0 0 rgba(108, 117, 125, 0); }
    }

    .grid button.active {
        /* A betűtípust az aktív osztályok kezelik */
        /* Alapértelmezett aktív szegély/árnyék, szükség esetén specifikusabb szabályok felülírják */
        border: 4px solid var(--muted); /* Alapértelmezett szürke szegély aktívhoz */
        box-shadow: var(--shadow-medium); /* Alapértelmezett közepes árnyék aktívhoz */
        animation-duration: 3s; /* Lassabb animáció minden aktív gombhoz */
        animation-iteration-count: infinite; /* Korlátlan animáció lejátszása */
    }
    .grid button.active:not(.empty-category) {
        font-weight: bold; /* Félkövér a fehér számhoz */
        color: #ffffff; /* Szöveg színe fehér */
        border: 4px solid #ffffff; /* Fehér szegély aktív, nem üres kategóriához */
        box-shadow: 0 15px 30px rgba(0, 0, 0, 0.4), 0 25px 50px rgba(0, 0, 0, 0.3); /* Sötétebb, kiemelkedőbb árnyék */
        animation-name: pulse-primary-dark; /* Alapértelmezett sötétkék pulzálás */
    }
    /* MÓDOSÍTVA: Köztes kék háttér és pulzálás aktív állapotban, ha van adat */
    #categoryGrid2 button.active:not(.empty-category) {
        background: var(--medium-primary);
        animation-name: pulse-medium-primary;
    }

    .grid button.active.empty-category {
        background: var(--card-bg);
        color: var(--muted); /* Szürke szöveg */
        animation-name: pulse-grey-less-intense; /* Alkalmazza az új, kevésbé intenzív szürke pulzálást */
        border: 4px solid var(--muted); /* Javított szegély 44px-ről 4px-re */
        font-weight: bold; /* Félkövérre állítja a számot */
    }
    .grid button.active:not(.empty-category) .day-letter {
        font-weight: bold; /* Félkövérre állítja a nap betűjét aktív, nem üres kategóriához */
    }

    /* ÚJ SZABÁLY: Ikon a gomb bal felső sarkában (L betű) */
    .grid button .fa-na-icon { /* Átneveztem a class-t a pontosabb leírásért */
        position: absolute;
        top: 5px;
        left: 5px;
        width: 1.2em; /* Méret beállítása */
        height: 1.2em; /* Méret beállítása */
        z-index: 10; /* Hogy a többi elem fölött legyen */
    }

    /* ÚJ SZABÁLY: Ikon a táblázat fejlécében a traverz szám mellett */
    .header-traverse-icon {
        width: 1.5em; /* Az ikon szélessége - egyforma a szám magasságával */
        height: 1.5em; /* Az ikon magassága - egyforma a szám magasságával */
        vertical-align: middle; /* Függőleges igazítás a szöveghez */
        margin-right: 5px; /* Távolság a szövegtől */
        display: inline-block; /* Fontos, hogy inline-block legyen a vertical-align miatt */
    }

    /* ÚJ SZABÁLY: Ikon a mainControls kategória címkéje mellett */
    .category-label-icon {
        /* A .controls .category-display-label font-size-a 2.2em, ehhez igazítjuk */
        width: 1em; /* Az ikon szélessége a szám magasságához igazítva */
        height: 1em; /* Az ikon magassága a szám magasságához igazítva */
        vertical-align: middle; /* Függőleges igazítás a szöveghez */
        margin-right: 10px; /* Távolság a számtól */
        display: inline-block; /* Fontos, hogy inline-block legyen a vertical-align miatt */
    }

    /* ÚJ: Jegyzet állapotjelző ikon a kategóriagombokon */
    .grid button .note-status-indicator {
        position: absolute;
        top: 5px;
        right: 5px;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 0.8em;
        z-index: 10;
        background: var(--danger);
        color: white;
        border: 1px solid var(--danger);
        box-shadow: var(--shadow-soft);
        animation: blink-red-white 1.5s infinite alternate; /* Ugyanaz az animáció, mint a táblázat jegyzet gombján */
    }
    .grid button .note-status-indicator i {
        text-shadow: none; /* A belső ikon árnyékát eltávolítjuk */
    }

    #mainControls {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0; /* Megváltoztatva width: 100%-ról right: 0-ra */
        z-index: 1000;
        /* display: none; */ /* Maradjon kikommentelve, a JS vezérli a láthatóságot */
        box-sizing: border-box;
        padding: 0 15px; /* Hozzáadva vízszintes padding, hogy illeszkedjen a body-hoz */
        background: transparent; /* Átlátszóra változtatva, lehetővé téve a belső div stílusát */
        border-top: none; /* Eltávolítva a konténerhez */
        box-shadow: none; /* Eltávolítva a konténerhez */
        flex-shrink: 0;
    }

    .controls {
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 10px;
        background: var(--card-bg);
        border-radius: 8px;
        box-shadow: var(--shadow-soft);
        border: 1px solid var(--border-color);
        box-sizing: border-box;
        width: 100%; /* Megváltoztatva max-width: fit-content-ről width: 100%-ra */
        margin: 10px 0; /* Megváltoztatva margin: 10px auto-ról margin: 10px 0-ra */
        flex-wrap: nowrap;
    }
    .controls .category-display-label {
        font-weight: bold;
        font-size: 2.2em;
        text-align: center;
        background: none;
        padding: 0;
        border-radius: 0;
        box-shadow: none;
        border: none;
        height: auto;
        flex-shrink: 1;
        flex-basis: auto;
        margin: 0 10px;
        line-height: 1; /* Hozzáadva, hogy a szöveg magassága pontosan a font-size legyen */
    }

    #categoryLabelRight {
        display: none; /* Ez az elem nem használt a jelenlegi felületen */
    }

    .controls .control-buttons {
        display: flex;
        gap: 15px;
        flex-wrap: nowrap;
        justify-content: center;
        align-items: center;
    }

    .controls button {
        font-size: 1.1em;
        padding: 14px 22px;
        border-radius: 6px;
        border: none;
        background: var(--primary);
        color: #fff;
        cursor: pointer;
        transition: all 0.1s ease;
        box-shadow: 0 10px 20px rgba(0, 0, 0, 0.25), 0 15px 30px rgba(0, 0, 0, 0.15);
        text-shadow: none;
    }

    .controls button.empty-category-control {
        background: var(--muted) !important;
        color: var(--text) !important; /* Szöveg színe is muted legyen */
        box-shadow: none !important;
    }

    .controls button:active {
        transform: scale(0.96);
        box-shadow: var(--shadow-active);
    }
    .controls button:hover {
        background: var(--primary-dark);
        box-shadow: var(--shadow-medium);
    }
    .controls button.empty-category-control:hover {
        background: #888 !important;
        box-shadow: none !important;
    }

    .controls button i {
        margin: 0 4px;
        font-size: 1.8em; /* Megnöveltem a vonalkód ikon méretét */
        text-shadow: 1px 1px 2px rgba(0,0,0,0.5); /* Árnyék a jobb láthatóságért */
    }
    
    #manualEntryBtn {
        padding: 18px 44px;
        font-size: 1.5em;
    }

    #clearCategoryBtn {
        background: var(--danger);
        padding: 14px 22px;
        font-size: 1.1em;
        box-shadow: 0 10px 20px rgba(0, 0, 0, 0.25), 0 15px 30px rgba(0, 0, 0, 0.15);
        color: #fff;
    }
    #clearCategoryBtn:hover {
        background: #c82333;
        box-shadow: 0 15px 30px rgba(0, 0, 0, 0.4), 0 25px 50px rgba(0, 0, 0, 0.3);
    }
    #clearCategoryBtn:active {
        transform: scale(0.96);
        box-shadow: var(--shadow-active);
    }


    #listSection {
        margin-top: 30px;
        display: block;
    }

    table {
        width: 100%;
        border-collapse: separate;
        border-spacing: 0;
        margin-top: 20px;
        background: var(--card-bg);
        border-radius: 8px;
        overflow: hidden;
        border: 1px solid var(--border-color);
        box-shadow: var(--shadow-soft);
        table-layout: fixed; /* Fixálja a cellaszélességeket */
    }
    th, td {
        border-bottom: 1px solid var(--border-color);
        padding: 15px 12px;
        text-align: center;
        vertical-align: middle;
        color: var(--text);
        text-overflow: ellipsis; /* ... ha túl hosszú a szöveg */
        white-space: normal; /* Engedélyezi a sortörést */
        word-wrap: break-word; /* Sortörés, ha szükséges */
    }
    th {
        background: #f0f0f0;
        font-weight: 700;
        color: var(--muted);
        font-size: 0.9em;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        text-shadow: none;
    }
    th:first-child { border-top-left-radius: 8px; }
    th:last-child { border-top-right-radius: 8px; }
    tr:last-child td { border-bottom: none; }

    #logBody tr:nth-child(even) { background-color: var(--row-alt-bg); }

    .auftrag-colored {
        color: var(--primary);
        font-weight: bold;
        font-size: 1.3em; /* 30%-kal nagyobb méret */
    }

    .auftrag-manual-bold {
        color: var(--text);
        font-weight: bold;
        font-size: 1.3em; /* 30%-kal nagyobb méret */
    }

    button:disabled { opacity: 0.6; cursor: not-allowed; box-shadow: none; }
    .deleteBtn {
        background: #f8d7da;
        color: var(--danger);
        border: 1px solid #f5c6cb;
        border-radius: 5px;
        padding: 8px 8px;
        font-size: 0.85em;
        font-weight: bold;
        transition: all 0.2s ease;
        display: inline-block;
        margin: 0 auto;
        box-shadow: none;
    }
    .deleteBtn:hover {
        background: var(--danger);
        color: #fff;
        box-shadow: var(--shadow-soft);
    }
    .deleteBtn:active {
        transform: scale(0.95);
        box-shadow: var(--shadow-active);
    }


    .noteToggleBtn {
        background: none;
        border: 1px solid transparent;
        cursor: pointer;
        color: var(--muted);
        line-height: 1;
        transition: transform 0.15s ease, color 0.15s ease, background-color 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
        display: inline-block;
        margin: 0 auto;
        box-shadow: none;
        border-radius: 6px;
        padding: 8px 8px;
        font-size: 1.5em;
    }
    .noteToggleBtn:hover { transform: scale(1.15); color: var(--primary); }

    .noteToggleBtn.note-filled {
        background: var(--danger);
        color: #fff;
        border-color: var(--danger);
        box-shadow: var(--shadow-soft);
        animation: blink-red-white 1.5s infinite alternate;
    }
    .noteToggleBtn.note-filled:hover {
        background: #c82333;
        border-color: #c82333;
        color: #fff;
        box-shadow: var(--shadow-medium);
        transform: scale(1.15);
        animation: none;
    }

    @keyframes blink-red-white {
        from { background-color: var(--danger); color: #fff; }
        to { background-color: #ffffff; color: var(--danger); }
    }

    td.photo-cell {
        padding: 10px;
    }
    .photoRow {
        display: flex;
        justify-content: center;
        gap: 5px;
        margin-bottom: 5px;
        flex-wrap: wrap; /* Képek tördelése új sorba, ha nem férnek el */
    }
    .photoRow:last-child {
        margin-bottom: 0;
    }
    .photoRow img {
        width: 60px;
        height: 60px;
        border-radius: 5px;
        border: 1px solid var(--border-color);
        cursor: pointer;
        object-fit: cover;
        background: var(--card-bg);
        box-shadow: var(--shadow-soft);
    }

    .addExtraPhotoBtn, .uploadPhotoBtn {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        padding: 8px 8px;
        font-size: 1.5em;
        border-radius: 6px;
        border: 1px solid var(--primary);
        background: var(--primary);
        color: #fff;
        cursor: pointer;
        transition: all 0.2s ease;
        margin: 0 auto;
        box-shadow: none;
    }
    .addExtraPhotoBtn:hover, .uploadPhotoBtn:hover {
        background: var(--primary-dark);
        border-color: var(--primary-dark);
        box-shadow: var(--shadow-medium);
    }
    .addExtraPhotoBtn:active, .uploadPhotoBtn:active {
        transform: scale(0.95);
        box-shadow: var(--shadow-active);
    }

    .modal-overlay {
        position: fixed;
        top:0; left:0; right:0; bottom:0;
        background: rgba(0,0,0,0.6);
        display: flex; /* Mindig flex a középre igazításhoz */
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 9999;
        padding: 20px;
        box-sizing: border-box;
        overflow: auto; /* Engedélyezi a görgetést mindkét irányba */
    }
    /* Alapértelmezésben rejtve, JS jeleníti meg */
    .modal-overlay:not([style*="display: flex"]) {
        display: none;
    }
    
    #imageModal.image-zoomed-in {
        justify-content: flex-start; /* Igazítás balra felülre görgetéshez */
        align-items: flex-start;
    }

    /* Eltávolítottam a padding-top-ot, hogy a flexbox középre igazítsa */
    #customPromptModal, #noteModal {
        padding-top: 0; 
    }
    #customConfirmModal {
        justify-content: center;
        padding-top: 0;
    }
    .modal-overlay video {
        width: 82vw;
        max-width: 700px;
        height: auto;
        border-radius: 8px;
        box-shadow: var(--shadow-medium);
        border: 1px solid var(--border-color);
    }
    .modal-controls {
        margin-top: 20px;
        display: flex;
        gap: 15px;
        flex-wrap: wrap;
        justify-content: center;
    }
    .modal-controls button {
        font-size: 1.05em;
        padding: 12px 20px;
        border-radius: 5px;
        border: none;
        background: var(--primary);
        color: #fff;
        backdrop-filter: none;
        box-shadow: var(--shadow-soft);
    }
    .modal-controls button:hover { background: var(--primary-dark); box-shadow: var(--shadow-medium); }
    .modal-controls button:active { transform: scale(0.98); }

    #imageModal .modal-controls {
        position: absolute;
        width: 100%;
        top: 50%;
        transform: translateY(-50%);
        display: flex;
        justify-content: space-between;
        padding: 0 20px;
        pointer-events: none; /* Átengedik a kattintásokat az alatta lévő képre */
    }

    #imageModal .modal-controls button {
        font-size: 2em;
        padding: 10px 15px;
        border-radius: 50%;
        background: rgba(0,0,0,0.3);
        color: #fff;
        border: 2px solid rgba(255,255,255,0.5);
        backdrop-filter: blur(5px);
        cursor: pointer;
        pointer-events: all; /* Visszaállítva, hogy kattintható legyen */
        transition: background-color 0.2s ease, transform 0.2s ease;
        box-shadow: var(--shadow-soft);
    }
    #imageModal .modal-controls button:hover {
        background: rgba(0,0,0,0.5);
        box-shadow: var(--shadow-medium);
    }
    #imageModal .modal-controls button:active {
        transform: scale(0.9) translateY(-50%);
    }
    #imageModal .modal-controls button:disabled {
        opacity: 0.3;
        cursor: default;
        box-shadow: none;
    }

    .delete-image-btn {
        position: absolute;
        top: 10px;
        right: 10px;
        z-index: 10001;
        background: var(--danger) !important;
        color: white !important;
        border: none !important;
        border-radius: 50% !important;
        width: 40px;
        height: 40px;
        padding: 0;
        font-size: 1.2em;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: var(--shadow-soft);
        transition: all 0.2s ease;
    }
    .delete-image-btn:hover {
        background: #c82333 !important;
        box-shadow: var(--shadow-medium) !important;
        transform: scale(1.1);
    }
    .delete-image-btn:active {
        transform: scale(0.95);
        box-shadow: var(--shadow-active);
    }


    #scannerDetectedCode { /* Ez az elem nincs használva a HTML-ben, de a stílusa megvan */
        margin-top: 18px;
        font-size: 1.2em;
        font-weight: 700;
        color: var(--primary);
        background: var(--card-bg);
        padding: 10px 20px;
        border-radius: 8px;
        min-height: 2.5em;
        text-align: center;
        line-height: 2.5em;
        box-shadow: var(--shadow-soft);
        border: 1px solid var(--border-color);
    }

    #imageModal img {
        max-width: 90vw;
        max-height: 90vh;
        border-radius: 8px;
        box-shadow: var(--shadow-medium);
        background: #000;
        border: 1px solid var(--border-color);
        cursor: zoom-in;
        transition: max-width 0.3s ease, max-height 0.3s ease;
    }

    /* FRISSÍTVE: Nagyított kép stílusa */
    #imageModal.image-zoomed-in #modalImage {
        max-width: none;
        max-height: none;
        cursor: zoom-out;
    }

    .note-modal-content {
        position: relative;
        background: var(--card-bg);
        padding: 25px;
        border-radius: 8px;
        width: 90vw;
        max-width: 680px;
        display: flex;
        flex-direction: column;
        gap: 18px;
        box-shadow: var(--shadow-medium);
        border: 1px solid var(--border-color);
    }
    .note-modal-content h2 {
        margin: 0 0 10px;
        font-size: 1.8em;
        color: var(--primary);
    }
    .note-modal-content p {
        color: var(--text);
    }
    .note-modal-content textarea {
        width: 100%;
        height: 160px;
        font-size: 1.5em;
        padding: 12px;
        box-sizing: border-box;
        border: 1px solid var(--border-color);
        border-radius: 5px;
        background: var(--bg);
        color: var(--text);
        resize: vertical;
        box-shadow: inset 0 2px 5px rgba(0,0,0,0.2);
        font-weight: bold;
    }
    .note-modal-content button {
        font-size: 1.05em;
        padding: 12px 20px;
        border-radius: 5px;
        background: var(--primary);
        color: #fff;
        border: none;
        align-self: flex-end;
        box-shadow: var(--shadow-soft);
        transition: all 0.2s ease;
    }
    .note-modal-content button:hover { background: var(--primary-dark); box-shadow: var(--shadow-medium); }
    .note-modal-content button:active { transform: scale(0.98); }

    .modal-category-number {
        position: static;
        font-size: 6em;
        font-weight: 700;
        line-height: 1;
        color: var(--muted);
    }

    #customAlertModal .note-modal-content,
    #customConfirmModal .note-modal-content {
        background: var(--card-bg);
        border: 1px solid var(--border-color);
        box-shadow: var(--shadow-medium);
    }
    
    #customPromptModal .note-modal-content {
        max-width: 456px;
        align-items: center;
        gap: 20px;
        /* Hozzáadva explicit háttér a prompt modál tartalmához */
        background-color: white !important; /* Fehér háttér kényszerítése */
    }

    #customAlertModal h2, #customConfirmModal h2, #customPromptModal h2 {
        display: none; /* A címeket a tartalomba ágyazva jelenítjük meg, nem külön h2-ként */
    }
    #customPromptMessage {
        display: none; /* Az üzenet is a modál tartalmába van integrálva */
    }

    #customPromptInput {
        background: var(--bg);
        border: 1px solid var(--border-color);
        color: var(--text);
        box-shadow: inset 0 2px 5px rgba(0,0,0,0.2);
        font-size: 2em;
        font-weight: bold;
    }
    /* Módosítva: OK gomb ikonjának mérete */
    #customPromptOkBtn i {
        font-size: 1.5em; /* Kicsit nagyobb pipa ikon */
    }
    /* MÓDOSÍTVA: Mégse gomb ikonjának mérete és hover árnyalata - Most egyforma az OK gomb ikonjával */
    #customPromptCancelBtn i {
        font-size: 1.5em; /* Kicsit nagyobb pipa ikon */
    }
    #customPromptCancelBtn:hover {
        background: #bbbbbb !important; /* Sötétebb árnyalat hoverre */
    }


    @media (max-width: 700px) {
        body { padding: 0 15px 30px; }
        .grid { padding: 15px; gap: 10px; }
        .grid button { padding: 16px 8px; font-size: 1.1em; }
        .controls { padding: 15px; gap: 10px; }
        .controls button { padding: 12px 18px; font-size: 1em; }
        table { display: block; overflow-x: auto; white-space: nowrap; border-radius: 8px; }
        th:first-child { border-top-left-radius: 8px; }
        th:last-child { border-top-right-radius: 8px; }
        .photo-cell img { width: 50px; height: 50px; border-radius: 4px; }
        .app-title { font-size: 1.2em; /* Az eredeti kódban nincs ilyen elem, de ez egy általános stílus */ }
    }

    /* ÚJ: Loading overlay stílusok */
    #loadingOverlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 10000;
        color: white;
        font-size: 1.5em;
        font-weight: bold;
        text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
    }

    .spinner {
        border: 8px solid rgba(255, 255, 255, 0.3);
        border-top: 8px solid #fff;
        border-radius: 50%;
        width: 60px;
        height: 60px;
        animation: spin 1s linear infinite;
        margin-bottom: 20px;
    }

    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
</head>
<body>

    <div id="main-scrollable-area">
        <div class="grid" id="categoryGrid1"></div>
        <div class="grid" id="categoryGrid2"></div>

        <div id="listSection">
            <table>
                <thead>
                    <tr>
                        <th id="traverse-header" width="6%">#</th>
                        <th width="29%">Auftrag</th>
                        <th width="15%">Datum</th>
                        <th width="8%">Notiz</th>
                        <th width="26%">Bilder</th>
                        <th width="8%"><i class="fas fa-folder" title="Bild hochladen"></i></th>
                        <th width="8%"><i class="fas fa-trash-alt" title="Löschen"></i></th>
                    </tr>
                </thead>
                <tbody id="logBody"></tbody>
            </table>
        </div>
    </div>

    <div id="mainControls">
        <div class="controls">
                <div id="categoryLabelLeft" class="category-display-label"></div>
                <div class="control-buttons">
                    <button id="manualEntryBtn" title="Manuelle Eingabe"><i class="fas fa-barcode"></i></button>
                    <button id="clearCategoryBtn" title="Kategorie löschen"><i class="fas fa-trash-alt"></i></button>
                </div>
        </div>
    </div>

    <div id="imageModal" class="modal-overlay">
        <img id="modalImage" src="" alt="Bild vergrößert" />
        <div class="modal-controls">
            <button id="imageModalPrevBtn" title="Vorheriges Bild"><i class="fas fa-chevron-left"></i></button>
            <button id="imageModalNextBtn" title="Nächstes Bild"><i class="fas fa-chevron-right"></i></button>
        </div>
        <button id="deleteImageBtn" class="delete-image-btn" title="Bild löschen"><i class="fas fa-trash-alt"></i></button>
    </div>

    <div id="noteModal" class="modal-overlay">
        <div class="note-modal-content">
            <h2>Notiz bearbeiten</h2>
            <textarea id="noteModalTextarea"></textarea>
            <div style="display: flex; justify-content: flex-end; align-items: center; gap: 10px;">
                <button id="noteModalSaveBtn">Speichern & Schließen</button>
            </div>
        </div>
    </div>

    <div id="customPromptModal" class="modal-overlay">
        <div class="note-modal-content">
            <span id="promptCategoryNumber" class="modal-category-number"></span>
            <h2 id="customPromptTitle">Manuelle Eingabe</h2>
            <p id="customPromptMessage">Bitte geben Sie den Produktnamen oder die Kennung ein:</p>
            <input type="text" id="customPromptInput" style="width: 100%; padding: 10px; border: 1px solid #d1d5db; border-radius: 8px;">
            <div style="display: flex; justify-content: center; gap: 10px; width: 100%;">
                <button id="customPromptCancelBtn" style="background: #ccc; color: var(--text); border: none; padding: 10px 15px; border-radius: 8px; cursor: pointer;" title="Abbrechen"><i class="fas fa-times"></i></button>
                <button id="customPromptOkBtn" style="background: var(--primary); color: white; border: none; padding: 10px 15px; border-radius: 8px; cursor: pointer;" title="OK"><i class="fas fa-check"></i></button>
            </div>
        </div>
    </div>
    
    <input type="file" id="imageUploadInput" accept="image/*" style="display: none;">

<div id="iconDataLoader" style="display: none;" data-icon-url="https://i.imgur.com/YpR6PdE.png"></div>

<!-- NEU: Loading Overlay Element -->
<div id="loadingOverlay" style="display: none;">
    <div class="spinner"></div>
    <span>Laden...</span>
</div>

<script>
/* --- IndexedDB (lokale DB) --- */
const db = (() => {
    let dbInstance;
    function openDB() {
        return new Promise((resolve, reject) => {
            if (dbInstance) { resolve(dbInstance); return; }
            const request = indexedDB.open('BarcodeDB_v2', 1);
            request.onerror = (event) => reject('Datenbankfehler: ' + event.target.errorCode);
            request.onsuccess = (event) => { dbInstance = event.target.result; resolve(dbInstance); };
            request.onupgradeneeded = (event) => {
                const db = event.target.result;
                // Erstellt einen "entries" Objektspeicher, falls nicht vorhanden.
                // "id" ist der Primärschlüssel, automatisch generiert mit autoIncrement.
                const objectStore = db.createObjectStore('entries', { keyPath: 'id', autoIncrement: true });
                // Erstellt einen "category" Index für Abfragen basierend auf der Kategorie.
                objectStore.createIndex('category', 'category', { unique: false });
                // Erstellt einen "category_code" Index zur Überprüfung der Einzigartigkeit von Kategorie und Code.
                objectStore.createIndex('category_code', ['category', 'code'], { unique: true });
            };
        });
    }
    // Führt eine Transaktion in IndexedDB aus
    async function performTransaction(storeName, mode, action) {
        const db = await openDB();
        const transaction = db.transaction(storeName, mode);
        const store = transaction.objectStore(storeName);
        return new Promise((resolve, reject) => {
            const request = action(store);
            request.onsuccess = () => resolve(request.result);
            request.onerror = (event) => reject(event.target.error);
        });
    }
    return {
        addEntry: (entry) => performTransaction('entries', 'readwrite', store => store.add(entry)),
        getEntriesForCategory: (category) => performTransaction('entries', 'readonly', store => store.index('category').getAll(category)),
        updateEntry: (entry) => performTransaction('entries', 'readwrite', store => store.put(entry)),
        deleteEntry: (id) => performTransaction('entries', 'readwrite', store => store.delete(id)),
        getEntryCountForCategory: (category) => performTransaction('entries', 'readonly', store => store.index('category').count(category)),
        clearCategory: async (category) => {
            const db = await openDB();
            const transaction = db.transaction('entries', 'readwrite');
            const store = transaction.objectStore('entries');
            const index = store.index('category');
            const request = index.openCursor(IDBKeyRange.only(category));
            request.onsuccess = (event) => {
                const cursor = event.target.result;
                if (cursor) { store.delete(cursor.primaryKey); cursor.continue(); }
            };
            return new Promise((resolve, reject) => { transaction.oncomplete = () => resolve(); transaction.onerror = (event) => reject(event.target.error); });
        }
    };
})();

/* --- Hauptanwendungslogik --- */

(async function(){
    // DOM-Elemente abrufen
    const categoryGrid1 = document.getElementById('categoryGrid1');
    const categoryGrid2 = document.getElementById('categoryGrid2');
    const categoryLabelLeft = document.getElementById('categoryLabelLeft');
    const mainControls = document.getElementById('mainControls');
    const listSection = document.getElementById('listSection');
    const logBody = document.getElementById('logBody');

    // Modale Elemente
    const imageModal = document.getElementById('imageModal');
    const modalImage = document.getElementById('modalImage');
    const noteModal = document.getElementById('noteModal');
    const noteModalTextarea = document.getElementById('noteModalTextarea');
    const noteModalSaveBtn = document.getElementById('noteModalSaveBtn');
    const deleteImageBtn = document.getElementById('deleteImageBtn');
    const imageUploadInput = document.getElementById('imageUploadInput');
    const customPromptModal = document.getElementById('customPromptModal'); // Hozzáadva: customPromptModal változó
    const loadingOverlay = document.getElementById('loadingOverlay'); // Hozzáadva: loadingOverlay elem

    // Steuerungsbuttons
    const manualEntryBtn = document.getElementById('manualEntryBtn');
    const clearCategoryBtn = document.getElementById('clearCategoryBtn');

    // Anwendungsstatus
    let currentCategory = null; // A jelenleg kiválasztott kategória száma
    let entries = []; // A jelenleg kiválasztott kategória bejegyzései
    let entryIdToUpdate = null; // A képfeltöltéshez kiválasztott bejegyzés ID-je
    let noteEntryIdToUpdate = null; // A jegyzet szerkesztéséhez kiválasztott bejegyzés ID-je

    // Globaler Status für das Bildkarussell im Modal
    let currentModalImages = []; // A jelenleg megjelenített képek listája
    let currentModalImageIndex = 0; // A jelenleg megjelenített kép indexe
    let currentImageEntryId = null; // Annak a bejegyzésnek az ID-je, amelyikhez a képek tartoznak

    // Laserscanner Eingabepuffer und Timer
    let laserScannerBuffer = [];
    let laserScannerTimer = null;

    // Loading Overlay Steuerungen
    function showLoading(message = "Laden...") {
        loadingOverlay.querySelector('span').textContent = message;
        loadingOverlay.style.display = 'flex';
        document.body.classList.add('modal-open'); // Verhindert das Scrollen des Hintergrunds
    }

    function hideLoading() {
        loadingOverlay.style.display = 'none';
        document.body.classList.remove('modal-open');
    }

    // Tastaturereignis-Handler für Scannereingabe und Esc-Taste
    window.addEventListener('keydown', (e) => {
        // Esc-Taste zum Schließen von Modalen
        if (e.key === 'Escape') {
            if (imageModal.style.display === 'flex') {
                closeModal(imageModal);
            } else if (noteModal.style.display === 'flex') {
                closeModal(noteModal);
            } else if (customPromptModal.style.display === 'flex') {
                closeModal(customPromptModal);
            }
            return; // Beendet, wenn ein Modal geschlossen wurde
        }

        // Wenn ein Modal geöffnet ist oder keine Kategorie ausgewählt wurde, Laserscanner-Eingabe nicht verarbeiten
        if (document.querySelector('.modal-overlay[style*="display: flex"]') || !currentCategory) {
            return;
        }

        // Enter-Taste nach Scannereingabe
        if (e.key === 'Enter' && laserScannerBuffer.length > 0) {
            e.preventDefault(); // Verhindert das Standardverhalten von Enter (z.B. Formular absenden)
            const scannedCode = laserScannerBuffer.join(''); // Fügt die Zeichen zusammen
            addNewEntry(scannedCode, null, 'laser'); // Fügt den neuen Eintrag hinzu
            laserScannerBuffer = []; // Leert den Puffer
            clearTimeout(laserScannerTimer); // Löscht den Timer
            return;
        }

        // Zeichen zum Scanner-Puffer hinzufügen
        if (e.key.length === 1) { // Verarbeitet nur einzelne Zeichentasten
            laserScannerBuffer.push(e.key);
            clearTimeout(laserScannerTimer); // Setzt den Timer bei jedem Tastendruck zurück
            // Der Timer leert den Puffer nach 100 ms, wenn keine weiteren Zeichen folgen
            laserScannerTimer = setTimeout(() => {
                laserScannerBuffer = [];
            }, 100);
        }
    });

    // Erstellt und initialisiert Kategorie-Buttons
    for(let i=1; i<=16; i++){
        const btn = document.createElement('button');
        btn.textContent = i;
        btn.addEventListener('click', () => selectCategory(i, btn));
        categoryGrid1.appendChild(btn);
    }
    for(let i=17; i<=28; i++){
        const btn = document.createElement('button');
        btn.textContent = i;
        btn.addEventListener('click', () => selectCategory(i, btn));
        categoryGrid2.appendChild(btn);
    }

    // Aktualisiert die Farben und Symbole der Kategorie-Buttons basierend auf den Daten
    async function updateCategoryButtonColors() {
        const allCategoryButtons = document.querySelectorAll('.grid button');
        // Icon-URL aus dem versteckten HTML-Element extrahieren
        const iconUrl = document.getElementById('iconDataLoader').dataset.iconUrl;

        for (const button of allCategoryButtons) {
            const categoryNum = parseInt(button.textContent);
            const entriesForCategory = await db.getEntriesForCategory(categoryNum);
            
            // Entfernt das Zeitsymbol, falls es bereits existiert
            const existingTimeIcon = button.querySelector('.time-icon');
            if (existingTimeIcon) {
                existingTimeIcon.remove();
            }

            // Entfernt den Tagesbuchstaben, falls er bereits existiert
            const existingDayLetter = button.querySelector('.day-letter');
            if(existingDayLetter) {
                existingDayLetter.remove();
            }

            // FA/NA-Icon vor jedem Update entfernen
            const existingFaNaIcon = button.querySelector('.fa-na-icon');
            if (existingFaNaIcon) {
                existingFaNaIcon.remove();
            }

            // NEU: Notiz-Status-Indikator entfernen
            const existingNoteIndicator = button.querySelector('.note-status-indicator');
            if (existingNoteIndicator) {
                existingNoteIndicator.remove();
            }

            let hasFaNaEntry = false;
            let hasNoteInAnyEntry = false; // NEU: Flag für Notiz in Kategorie
            if (entriesForCategory.length > 0) {
                button.classList.remove('empty-category'); // Wenn Daten vorhanden sind, ist es keine leere Kategorie
                
                // Neuesten Eintrag für Zeit- und Tagessymbol finden
                const latestEntry = entriesForCategory.sort((a, b) => new Date(b.date) - new Date(a.date))[0];
                const entryDate = new Date(latestEntry.date);
                const entryHour = entryDate.getHours();

                const today = new Date();
                today.setHours(0, 0, 0, 0); // Setzt den Beginn des heutigen Tages
                const isPreviousDay = entryDate < today; // Überprüft, ob es sich um den Vortag handelt

                const icon = document.createElement('i');
                icon.classList.add('fas', 'time-icon');
                if (entryHour < 14) { // Wenn vor 14 Uhr (vormittags)
                    icon.classList.add('fa-sun');
                    icon.style.color = isPreviousDay ? '#666666' : 'yellow'; // Grau, wenn Vortag; Gelb, wenn heute
                } else { // Wenn nach 14 Uhr (nachmittags)
                    icon.classList.add('fa-moon');
                    icon.style.color = isPreviousDay ? '#666666' : '#F9E79F'; // Grau, wenn Vortag; Hellgelb, wenn heute
                }
                button.appendChild(icon);

                const days = ['So', 'Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa']; // Tage auf Deutsch abgekürzt
                const dayIndex = entryDate.getDay();
                const daySpan = document.createElement('span');
                daySpan.className = 'day-letter';
                daySpan.textContent = days[dayIndex];
                button.appendChild(daySpan);

                // Überprüfen, ob ein Eintrag mit FA oder NA beginnt
                hasFaNaEntry = entriesForCategory.some(entry => entry.code && (entry.code.startsWith('FA') || entry.code.startsWith('NA')));
                // NEU: Überprüfen, ob ein Eintrag eine Notiz hat
                hasNoteInAnyEntry = entriesForCategory.some(entry => entry.note && entry.note.trim() !== '');

            } else {
                button.classList.add('empty-category'); // Wenn keine Daten vorhanden sind, ist es eine leere Kategorie
            }

            // FA/NA-Icon hinzufügen, falls ein solcher Eintrag vorhanden ist
            if (hasFaNaEntry) {
                const faNaIcon = document.createElement('img'); // Als Bild einfügen
                faNaIcon.src = iconUrl; // URL des Icons aus dem versteckten HTML-Element
                faNaIcon.alt = 'Traversen-Status-Icon';
                faNaIcon.classList.add('fa-na-icon');
                button.appendChild(faNaIcon);
            }

            // NEU: Notiz-Status-Indikator hinzufügen, falls eine Notiz vorhanden ist
            if (hasNoteInAnyEntry) {
                const noteIndicator = document.createElement('div');
                noteIndicator.classList.add('note-status-indicator');
                const noteIcon = document.createElement('i');
                noteIcon.classList.add('fas', 'fa-sticky-note'); // Oder fa-clipboard, fa-book
                noteIndicator.appendChild(noteIcon);
                button.appendChild(noteIndicator);
            }
        }
    }

    // Aktualisiert die Farbe der unteren Steuerungsbuttons (manuelle Eingabe)
    function updateControlButtonsColor(isEmpty) {
        if (isEmpty) {
            manualEntryBtn.classList.add('empty-category-control');
        } else {
            manualEntryBtn.classList.remove('empty-category-control');
        }
    }

    // Ereignis-Handler für Kategorieauswahl
    async function selectCategory(num, btn){
        if(currentCategory === num) return; // Wenn diese Kategorie bereits ausgewählt ist, nichts tun
        
        // Entfernt die "active"-Klasse vom zuvor ausgewählten Button
        const prevActive = document.querySelector('.grid button.active');
        if(prevActive) prevActive.classList.remove('active');
        
        btn.classList.add('active'); // Fügt die "active"-Klasse zum aktuellen Button hinzu
        currentCategory = num; // Setzt die aktuelle Kategorie
        
        try {
            showLoading("Traversendaten laden...");
            // Einträge der ausgewählten Kategorie aus der Datenbank abrufen
            entries = await db.getEntriesForCategory(currentCategory);
            const isEmpty = entries.length === 0; // Feststellen, ob die Kategorie leer ist
            
            updateHeaderAndControls(); // Aktualisiert das Label der unteren Steuerleiste
            updateTraverseHeader(); // Aktualisiert den Tabellenkopf
            
            mainControls.style.display = 'block'; // Zeigt die untere Steuerleiste an
            listSection.style.display = 'block'; // Zeigt die Datenliste an
            renderTable(); // Zeichnet die Tabelle mit den Einträgen neu
            await updateCategoryButtonColors(); // Aktualisiert die Farben der Kategorie-Buttons
            updateControlButtonsColor(isEmpty); // Aktualisiert die Farbe des manuellen Eingabe-Buttons
        }
        catch (e) {
            console.error("Fehler beim Lesen der Datenbank:", e);
            showCustomAlert('Fehler beim Laden der Traversendaten.', 'Fehler');
        } finally {
            hideLoading();
        }
    }

    // Hilfsfunktion zum Aktualisieren des unteren Labels und der Steuerleiste
    function updateHeaderAndControls() {
        if (!currentCategory) {
            categoryLabelLeft.innerHTML = ''; /* Den HTML-Inhalt festlegen */
            categoryLabelLeft.style.color = 'var(--muted)';
            return;
        }

        const isEmpty = entries.length === 0;
        // SVG-Code des Icons, Farbe dynamisch gesetzt
        const iconColor = isEmpty ? '%236c757d' : '%230056b3'; /* Grau oder Blau */
        // NEU: SVG-Code des Icons mit Basen, angepasst für bessere visuelle Höhe
        const iconSvg = `<img src='data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"%3E%3Crect x="10" y="5" width="10" height="70" fill="${iconColor}"/%3E%3Crect x="80" y="5" width="10" height="70" fill="${iconColor}"/%3E%3Crect x="0" y="30" width="100" height="15" fill="${iconColor}"/%3E%3Crect x="0" y="80" width="30" height="10" fill="${iconColor}"/%3E%3Crect x="70" y="80" width="30" height="10" fill="${iconColor}"/%3E%3C/svg%3E' alt="Traversen-Icon" class="category-label-icon">`;

        // innerHTML mit Icon und Kategorienummer setzen
        categoryLabelLeft.innerHTML = `${iconSvg} ${currentCategory}`;
        categoryLabelLeft.style.color = isEmpty ? 'var(--muted)' : 'var(--primary)';
    }

    // NEU: Funktion zum Aktualisieren des Tabellenkopfes
    function updateTraverseHeader() {
        const traverseHeader = document.getElementById('traverse-header');
        if (!currentCategory) {
            traverseHeader.innerHTML = '#'; /* Den HTML-Inhalt festlegen */
            traverseHeader.style.color = 'var(--muted)';
            traverseHeader.style.fontWeight = 'bold';
            traverseHeader.style.fontSize = '0.9em'; /* Setzt die Größe auf Standard zurück, wenn nichts ausgewählt ist */
            return;
        }

        const isEmpty = entries.length === 0;
        // SVG-Code des Icons, Farbe dynamisch gesetzt
        const iconColor = isEmpty ? '%236c757d' : '%230056b3'; /* Grau oder Blau */
        // NEU: SVG-Code des Icons mit Basen, angepasst für bessere visuelle Höhe
        const iconSvg = `<img src='data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"%3E%3Crect x="10" y="5" width="10" height="70" fill="${iconColor}"/%3E%3Crect x="80" y="5" width="10" height="70" fill="${iconColor}"/%3E%3Crect x="0" y="30" width="100" height="15" fill="${iconColor}"/%3E%3Crect x="0" y="80" width="30" height="10" fill="${iconColor}"/%3E%3Crect x="70" y="80" width="30" height="10" fill="${iconColor}"/%3E%3C/svg%3E' alt="Traversen-Icon" class="header-traverse-icon">`;

        // innerHTML mit Icon und Kategorienummer setzen
        traverseHeader.innerHTML = `${iconSvg} ${currentCategory}`;
        traverseHeader.style.color = isEmpty ? 'var(--muted)' : 'var(--primary)';
        traverseHeader.style.fontWeight = 'bold';
        traverseHeader.style.fontSize = '1.5em'; /* Erhöht die Schriftgröße für die Kopfzeilennummer */
    }

    // Zeigt ein benutzerdefiniertes Alert-Modal an
    function showCustomAlert(message, title = 'Information') {
        const existingModal = document.getElementById('customAlertModal');
        if (existingModal) existingModal.remove(); // Entfernt das vorherige Alert-Modal, falls vorhanden

        const alertModal = document.createElement('div');
        alertModal.id = 'customAlertModal';
        alertModal.classList.add('modal-overlay');
        alertModal.innerHTML = `
            <div class="note-modal-content">
                <h2>${title}</h2>
                <p>${message}</p>
                <button id="customAlertCloseBtn" style="background: var(--primary); color: white; border: none; padding: 10px 15px; border-radius: 8px; cursor: pointer; align-self: flex-end;">OK</button>
            </div>
        `;
        document.body.appendChild(alertModal);
        alertModal.style.display = 'flex'; // Zeigt das Modal an
        document.body.classList.add('modal-open'); // Verhindert das Scrollen des Hintergrunds

        document.getElementById('customAlertCloseBtn').addEventListener('click', () => {
            alertModal.style.display = 'none';
            document.body.classList.remove('modal-open');
            alertModal.remove(); // Entfernt das Element aus dem DOM
        });
        // Klick außerhalb des Modals behandeln
        alertModal.addEventListener('click', (e) => {
            if (e.target === alertModal) { // Wenn auf das Overlay geklickt wird
                alertModal.style.display = 'none';
                document.body.classList.remove('modal-open');
                alertModal.remove();
            }
        });
    }

    // Einfaches Bestätigungs-Modal zum Löschen von Bildern
    function showSimpleConfirm(message, title = 'Bestätigung') {
        return new Promise(resolve => {
            const existingModal = document.getElementById('customConfirmModal');
            if (existingModal) existingModal.remove(); // Entfernt das vorherige Modal, falls vorhanden

            const confirmModal = document.createElement('div');
            confirmModal.id = 'customConfirmModal';
            confirmModal.classList.add('modal-overlay');
            
            confirmModal.innerHTML = `
                <div class="note-modal-content">
                    <h2>${title}</h2>
                    <p>${message}</p>
                    <div style="display: flex; justify-content: flex-end; gap: 10px; width: 100%; margin-top: 20px;">
                        <button id="customConfirmCancelBtn">Abbrechen</button>
                        <button id="customConfirmOkBtn">OK</button>
                    </div>
                </div>
            `;
            document.body.appendChild(confirmModal);
            confirmModal.style.display = 'flex';
            document.body.classList.add('modal-open');

            const okBtn = document.getElementById('customConfirmOkBtn');
            const cancelBtn = document.getElementById('customConfirmCancelBtn');

            const close = (result) => {
                confirmModal.style.display = 'none';
                document.body.classList.remove('modal-open');
                confirmModal.remove();
                resolve(result);
            };

            okBtn.addEventListener('click', () => close(true));
            cancelBtn.addEventListener('click', () => close(false));
            confirmModal.addEventListener('click', (e) => {
                if (e.target === confirmModal) {
                    close(false);
                }
            });
        });
    }

    // Komplexeres Bestätigungs-Modal mit PDF-Export-Option
    function showCustomConfirm(message, title = 'Bestätigung', entry = null) {
        return new Promise(resolve => {
            const existingModal = document.getElementById('customConfirmModal');
            if (existingModal) existingModal.remove();

            const confirmModal = document.createElement('div');
            confirmModal.id = 'customConfirmModal';
            confirmModal.classList.add('modal-overlay');
            
            // Standardmäßiger Hakenstatus: Aktiviert, wenn der Eintrag nicht FA/NA ist (d.h. bei FA/NA nicht aktiviert)
            const isCheckedByDefault = !(entry && (entry.code.startsWith('FA') || entry.code.startsWith('NA')));

            confirmModal.innerHTML = `
                <div class="note-modal-content">
                    <h2>${title}</h2>
                    <p>${message}</p>
                    <div style="display: flex; align-items: center; justify-content: space-between; width: 100%; margin-top: 20px; flex-wrap: wrap; gap: 10px;">
                        <label style="display: flex; align-items: center; cursor: pointer; font-size: 0.9em;">
                            <input type="checkbox" id="exportPdfCheckbox" ${isCheckedByDefault ? 'checked' : ''} style="margin-right: 8px; width: 18px; height: 18px; transform: scale(1.2);">
                            PDF exportieren
                        </label>
                        <div style="display: flex; gap: 10px;">
                            <button id="customConfirmCancelBtn">Abbrechen</button>
                            <button id="customConfirmOkBtn">Löschen</button>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(confirmModal);
            confirmModal.style.display = 'flex';
            document.body.classList.add('modal-open');

            document.getElementById('customConfirmOkBtn').addEventListener('click', () => {
                const exportPdf = document.getElementById('exportPdfCheckbox').checked;
                confirmModal.style.display = 'none';
                document.body.classList.remove('modal-open');
                confirmModal.remove();
                resolve({ confirmed: true, exportPdf: exportPdf });
            });
            document.getElementById('customConfirmCancelBtn').addEventListener('click', () => {
                confirmModal.style.display = 'none';
                document.body.classList.remove('modal-open');
                confirmModal.remove();
                resolve({ confirmed: false, exportPdf: false });
            });
            confirmModal.addEventListener('click', (e) => {
                if (e.target === confirmModal) {
                    close(false);
                }
            });
        });
    }

    // Öffnet das Bild-Modal
    function openImageModal(images, startIndex, entryId) {
        currentModalImages = images;
        currentModalImageIndex = startIndex;
        currentImageEntryId = entryId;

        modalImage.src = currentModalImages[currentModalImageIndex];
        modalImage.classList.remove('zoomed'); // Entfernt die "zoomed"-Klasse
        imageModal.style.display = 'flex';
        document.body.classList.add('modal-open');

        updateImageModalNavigation();
    }

    // Aktualisiert den Zustand der Navigationsbuttons im Bild-Modal
    function updateImageModalNavigation() {
        const prevBtn = document.getElementById('imageModalPrevBtn');
        const nextBtn = document.getElementById('imageModalNextBtn');

        if (currentModalImages.length <= 1) {
            prevBtn.style.display = 'none';
            nextBtn.style.display = 'none';
        } else {
            prevBtn.style.display = 'inline-flex';
            nextBtn.style.display = 'inline-flex';
            prevBtn.disabled = (currentModalImageIndex === 0); // Deaktiviert den vorherigen Button, wenn es das erste Bild ist
            nextBtn.disabled = (currentModalImageIndex === currentModalImages.length - 1); // Deaktiviert den nächsten Button, wenn es das letzte Bild ist
        }
    }

    // Zeigt das nächste Bild im Karussell an
    function showNextImage() {
        if (currentModalImageIndex < currentModalImages.length - 1) {
            currentModalImageIndex++;
            modalImage.src = currentModalImages[currentModalImageIndex];
            modalImage.classList.remove('zoomed');
            updateImageModalNavigation();
        }
    }

    // Zeigt das vorherige Bild im Karussell an
    function showPrevImage() {
        if (currentModalImageIndex > 0) {
            currentModalImageIndex--;
            modalImage.src = currentModalImages[currentModalImageIndex];
            modalImage.classList.remove('zoomed');
            updateImageModalNavigation();
        }
    }

    // Löscht das aktuelle Bild aus dem Modal und der Datenbank
    async function deleteCurrentImage() {
        if (!currentImageEntryId || currentModalImages.length === 0) {
            showCustomAlert('Kein Bild zum Löschen vorhanden.', 'Fehler');
            return;
        }

        const confirmed = await showSimpleConfirm('Sind Sie sicher, dass Sie dieses Bild löschen möchten?', 'Bild löschen');
        if (!confirmed) {
            return;
        }

        showLoading("Bild wird gelöscht...");
        try {
            let entry = entries.find(e => e.id === currentImageEntryId);
            if (entry) {
                const imageUrlToDelete = currentModalImages[currentModalImageIndex];

                // Überprüft, ob das zu löschende Bild das Hauptbild ist
                if (entry.image === imageUrlToDelete) {
                    if (entry.kepek && entry.kepek.length > 0) {
                        // Wenn weitere Bilder im "kepek"-Array vorhanden sind, wird das erste zum Hauptbild
                        entry.image = entry.kepek.shift(); // Entfernt das erste Element und gibt es zurück
                    } else {
                        entry.image = null; // Wenn keine weiteren Bilder vorhanden sind, wird auch das Hauptbild null
                    }
                } else if (entry.kepek) {
                    // Wenn das zu löschende Bild im "kepek"-Array ist
                    const indexToDelete = entry.kepek.indexOf(imageUrlToDelete);
                    if (indexToDelete > -1) {
                        entry.kepek.splice(indexToDelete, 1); // Entfernt das Bild aus dem Array
                    }
                }

                await db.updateEntry(entry); // Aktualisiert den Eintrag in der Datenbank
                entries = entries.map(e => e.id === entry.id ? entry : e); // Aktualisiert das lokale "entries"-Array
                renderTable(); // Tabelle neu zeichnen

                // Bild-Modal mit den verbleibenden Bildern neu öffnen oder schließen, wenn keine Bilder mehr vorhanden sind
                const allRemainingImages = [entry.image, ...(entry.kepek || [])].filter(Boolean);
                if (allRemainingImages.length > 0) {
                    // Setzt den richtigen Index, falls das gelöschte Bild das letzte war
                    if (currentModalImageIndex >= allRemainingImages.length) {
                        currentModalImageIndex = allRemainingImages.length - 1;
                    }
                    openImageModal(allRemainingImages, currentModalImageIndex, currentImageEntryId);
                } else {
                    closeModal(imageModal);
                }
            }
        } catch (error) {
            console.error("Fehler beim Löschen des Bildes:", error);
            showCustomAlert('Fehler beim Löschen des Bildes.', 'Fehler');
        } finally {
            hideLoading();
        }
    }


    // renderTable mit der Spalte für die laufende Nummer
    function renderTable(){
        // Sortieren nach Datum, neuestes zuerst
        const sortedEntries = entries.slice().sort((a,b)=> new Date(b.date) - new Date(a.date));
        logBody.innerHTML = sortedEntries.map((e,i) => {
            const entryDate = new Date(e.date);
            const formattedDate = entryDate.toLocaleDateString('de-DE'); // Datum formatieren
            const formattedTime = entryDate.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' }); // Zeit formatieren

            // Sammelt alle Bilder (Hauptbild + zusätzliche Bilder)
            const allImageSources = [e.image, ...(e.kepek || [])].filter(Boolean);
            let photosCellHtml = '';
            // Képek megjelenítése 3-as csoportokban egy sorban
            for (let j = 0; j < allImageSources.length; j += 3) {
                photosCellHtml += `<div class="photoRow">${allImageSources.slice(j, j + 3).map(src => `<img src="${src}" alt="Bild">`).join('')}</div>`;
            }

            const noteTitle = e.note ? 'Notiz öffnen' : 'Notiz hinzufügen'; // Tooltip für Notiz-Button

            let codeClass = '';
            // CSS-Klasse basierend auf dem Code hinzufügen
            if (e.code && (e.code.startsWith('FA') || e.code.startsWith('NA'))) {
                codeClass = 'auftrag-colored'; // Farbige FA/NA Codes
            } else if (e.source === 'scanner' || e.source === 'manual' || e.source === 'laser') {
                codeClass = 'auftrag-manual-bold'; // Fettgedruckte manuelle oder gescannte Codes
            }

            return `
            <tr data-id="${e.id}">
                <td>
                    ${i + 1} <!-- Laufende Nummer -->
                </td>
                <td class="${codeClass}">
                    ${e.code} <!-- Der Auftragscode -->
                </td>
                <td>
                    ${formattedDate}<br>
                    <span style="font-size: 0.85em; color: var(--muted);"> ${formattedTime}</span>
                </td>
                <td><button class="noteToggleBtn ${e.note ? 'note-filled' : ''}" data-id="${e.id}" title="${noteTitle}" aria-label="${noteTitle}"><i class="fas ${e.note ? 'fa-sticky-note' : 'fa-plus'}"></i></button></td>
                <td class="photo-cell">${photosCellHtml}</td>
                <td><button class="uploadPhotoBtn" data-id="${e.id}" title="Bild hochladen"><i class="fas fa-folder"></i></button></td>
                <td><button class="deleteBtn" data-id="${e.id}" data-code="${e.code}" title="Löschen"><i class="fas fa-trash-alt"></i></button></td>
            </tr>`;
        }).join('');
        attachTableEventListeners(); // Fügt Ereignis-Listener zu den neu erstellten Elementen hinzu
    }

    // Fügt Ereignis-Listener zu den Tabellenelementen hinzu
    function attachTableEventListeners() {
        logBody.querySelectorAll('.deleteBtn').forEach(btn => btn.addEventListener('click', handleDelete));
        logBody.querySelectorAll('.noteToggleBtn').forEach(btn => btn.addEventListener('click', openNoteModal));
        logBody.querySelectorAll('.photo-cell img').forEach(img => img.addEventListener('click', (event) => {
            const entryId = parseInt(event.target.closest('tr').dataset.id);
            const entry = entries.find(e => e.id === entryId);
            if (entry) {
                const allImageSources = [entry.image, ...(entry.kepek || [])].filter(Boolean);
                const clickedImageSrc = event.target.src;
                const clickedImageIndex = allImageSources.indexOf(clickedImageSrc);
                openImageModal(allImageSources, clickedImageIndex, entryId);
            }
        }));
        logBody.querySelectorAll('.uploadPhotoBtn').forEach(btn => btn.addEventListener('click', handleUploadPhotoClick));
    }
    
    // Lädt ein Bild (gibt ein Promise mit einem Image-Objekt zurück)
    function loadImage(src) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.crossOrigin = 'Anonymous'; // Wichtig für Cross-Origin-Bilder (falls vorhanden)
            img.onload = () => resolve(img);
            img.onerror = () => {
                console.warn(`Fehler beim Laden des Bildes für PDF: ${src.substring(0, 50)}...`);
                reject(new Error('Fehler beim Laden des Bildes für die Bereinigung.'));
            };
            img.src = src;
        });
    }

    // --- PDF-GENERIERUNG (VERBESSERT) ---
    async function generatePdfForEntry(entry) {
        if (typeof window.jspdf === 'undefined') {
            console.error('jsPDF ist nicht geladen!');
            showCustomAlert('PDF-Export fehlgeschlagen: jsPDF Bibliothek nicht geladen.', 'Fehler');
            return;
        }
        showLoading("PDF wird generiert...");
        const { jsPDF } = window.jspdf;
        const doc = new jsPDF();

        const entryDate = new Date(entry.date);
        const formattedDateTime = entryDate.toLocaleString('de-DE', {
            year: 'numeric', month: '2-digit', day: '2-digit',
            hour: '2-digit', minute: '2-digit'
        });
        const entryHour = entryDate.getHours();
        const shiftText = entryHour < 14 ? 'Frühschicht' : 'Spätschicht'; // Schicht bestimmen

        // Überschrift
        doc.setFontSize(24);
        doc.setFont(undefined, 'bold');
        doc.text(`Auftrag: ${entry.code}`, 10, 20);

        doc.setFont(undefined, 'normal');
        doc.setFontSize(18);
        doc.text(`Datum: ${formattedDateTime}`, 10, 35);
        
        doc.text(shiftText, 10, 50);

        doc.text('Traverse: ', 10, 65);
        doc.setFont(undefined, 'bold');
        // Positionierung der Kategorienummer nach "Traverse:"
        doc.text(String(entry.category), 10 + doc.getStringUnitWidth('Traverse: ') * 18 / doc.internal.scaleFactor, 65);
        doc.setFont(undefined, 'normal');

        let yPos = 80;
        // Notiz hinzufügen, falls vorhanden
        if (entry.note) {
            doc.setFontSize(18);
            const noteWithLabel = `Notiz: ${entry.note}`;
            const splitText = doc.splitTextToSize(noteWithLabel, 180); // Text umbrechen
            doc.text(splitText, 10, yPos);
            yPos += (splitText.length * 10); // Höhe der Notiz hinzufügen
        }

        // Bilder laden és hinzufügen
        const allImageSources = [entry.image, ...(entry.kepek || [])].filter(Boolean);
        // Paralleles Laden von Bildern mit Promise.allSettled zur Fehlerbehandlung
        const imageLoadResults = await Promise.allSettled(allImageSources.map(loadImage));
        
        const loadedImages = [];
        let failedImageCount = 0;
        imageLoadResults.forEach(result => {
            if (result.status === 'fulfilled') {
                loadedImages.push(result.value);
            } else {
                console.error("Ein Bild konnte nicht für PDF geladen werden:", result.reason);
                failedImageCount++;
            }
        });

        if (failedImageCount > 0) {
            showCustomAlert(`${failedImageCount} Bilder konnten nicht für den PDF-Export geladen werden und wurden übersprungen.`, 'Warnung');
        }

        for (let i = 0; i < loadedImages.length; i++) {
            const imageData = loadedImages[i];
            yPos += 10; // Kleiner Rand vor dem Bild
            if (yPos > 220) { // Neue Seite, wenn nicht genug Platz ist
                doc.addPage();
                yPos = 10;
            }
            doc.setFontSize(18);
            doc.text(`Bild ${i + 1}`, 10, yPos); // Bildbeschriftung
            yPos += 8; // Rand zwischen Bildbeschriftung und Bild

            try {
                const imgProps = doc.getImageProperties(imageData);
                const pdfWidth = doc.internal.pageSize.getWidth();
                const pdfHeight = doc.internal.pageSize.getHeight();
                const maxWidth = pdfWidth - 20; // 10px Rand auf jeder Seite
                const maxHeight = pdfHeight - yPos - 10; // Platz für das Bild bis zum Seitenende

                let imgWidth = imgProps.width;
                let imgHeight = imgProps.height;
                const ratio = imgWidth / imgHeight;

                // Bildgröße anpassen, damit es auf die Seite passt
                if (imgWidth > maxWidth) {
                    imgWidth = maxWidth;
                    imgHeight = imgWidth / ratio;
                }
                if (imgHeight > maxHeight) {
                    imgHeight = maxHeight;
                    imgWidth = imgHeight * ratio;
                }

                if (yPos + imgHeight > pdfHeight - 10) { // Neue Seite, ha das Bild nicht passt
                    doc.addPage();
                    yPos = 10;
                }

                doc.addImage(imageData, undefined, 10, yPos, imgWidth, imgHeight); // Bild hinzufügen
                yPos += imgHeight + 5; // Höhe des Bildes és einen kleinen Rand hinzufügen
            } catch (e) {
                console.error("Fehler beim Hinzufügen des Bildes zum PDF:", e);
                if (yPos > 280) { doc.addPage(); yPos = 10; } // Neue Seite, wenn zu viele Fehlermeldungen vorhanden sind
                doc.text(`[Bild ${i + 1} konnte nicht verarbeitet werden]`, 10, yPos); // Fehlermeldung ins PDF
                yPos += 15;
            }
        }
        
        doc.save(`${entry.code}_trav${entry.category}.pdf`); // PDF als Datei speichern
        hideLoading();
    }

    // Löschereignis-Handler
    async function handleDelete(event) {
        const id = parseInt(event.currentTarget.dataset.id);
        const entryToDelete = entries.find(e => e.id === id);
        if (!entryToDelete) return; // Wenn der Eintrag nicht gefunden wird, beenden

        // Bestätigung mit PDF-Export-Option anfordern
        const result = await showCustomConfirm(`Sind Sie sicher, dass Sie den Eintrag "${entryToDelete.code}" löschen möchten?`, 'Bestätigung', entryToDelete);
        
        if (result.confirmed) {
            showLoading("Eintrag wird gelöscht...");
            try {
                if (result.exportPdf) {
                    await generatePdfForEntry(entryToDelete); // PDF generieren, wenn vom Benutzer angefordert
                }
                
                await db.deleteEntry(id); // Eintrag aus der Datenbank löschen
                entries = entries.filter(e => e.id !== id); // Eintrag aus dem lokalen Array entfernen
                renderTable(); // Tabelle neu zeichnen
                await updateCategoryButtonColors(); // Farben der Kategorie-Buttons aktualisieren
                updateTraverseHeader(); // Kopfzeile nach dem Löschen aktualisieren

                const count = await db.getEntryCountForCategory(currentCategory);
                if (count === 0) { // Wenn die Kategorie leer ist
                    categoryLabelLeft.style.color = 'var(--muted)';
                    updateControlButtonsColor(true); // Farbe des manuellen Eingabe-Buttons aktualisieren
                }
            } catch (error) {
                console.error("Fehler beim Löschen oder Exportieren.", error);
                showCustomAlert('Fehler beim Löschen oder Exportieren.', 'Fehler');
            } finally {
                hideLoading();
            }
        }
    }

    // Öffnet das Notiz-Modal
    function openNoteModal(event) {
        noteEntryIdToUpdate = parseInt(event.currentTarget.dataset.id);
        const entry = entries.find(e => e.id === noteEntryIdToUpdate);
        if (entry) {
            noteModalTextarea.value = entry.note || ''; // Lädt die Notiz oder einen leeren String
            noteModal.style.display = 'flex';
            document.body.classList.add('modal-open');
        }
    }

    // Speichert die Notiz aus dem Modal
    async function saveNoteFromModal() {
        showLoading("Notiz wird gespeichert...");
        try {
            const entry = entries.find(e => e.id === noteEntryIdToUpdate);
            if (entry) {
                entry.note = noteModalTextarea.value; // Notiz aktualisieren
                await db.updateEntry(entry); // In Datenbank speichern
                renderTable(); // Tabelle neu zeichnen
                await updateCategoryButtonColors(); // NEU: Kategorie-Buttons aktualisieren nach Notiz-Speicherung
            }
            noteModal.style.display = 'none';
            document.body.classList.remove('modal-open');
        } catch (error) {
            console.error("Fehler beim Speichern der Notiz:", error);
            showCustomAlert('Fehler beim Speichern der Notiz.', 'Fehler');
        } finally {
            hideLoading();
        }
    }

    // Ereignis-Handler für den Bild-Upload-Button-Klick
    function handleUploadPhotoClick(event) {
        entryIdToUpdate = parseInt(event.currentTarget.dataset.id);
        imageUploadInput.click(); // Aktiviert das versteckte Dateiauswahl-Input
    }
    
    // Bereinigt das Bild (Größenanpassung/Komprimierung in JPEG)
    function sanitizeImage(imageDataUrl, quality = 0.95) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => {
                const canvas = document.createElement('canvas');
                canvas.width = img.naturalWidth;
                canvas.height = img.naturalHeight;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0);
                resolve(canvas.toDataURL('image/jpeg', quality)); // Konvertierung in JPEG-Format
            };
            img.onerror = () => {
                console.warn(`Fehler beim Bereinigen des Bildes: ${imageDataUrl.substring(0, 50)}...`);
                reject(new Error('Fehler beim Laden des Bildes zur Bereinigung.'));
            };
            img.src = imageDataUrl;
        });
    }

    // Ereignis-Handler für Dateiauswahl (für Bild-Upload)
    async function handleFileSelected(event) {
        const file = event.target.files[0];
        if (!file || !entryIdToUpdate) return;

        showLoading("Bild wird verarbeitet...");
        const reader = new FileReader();
        reader.onload = async (e) => {
            try {
                // Bild zur Größenreduzierung bereinigen
                const sanitizedImageDataUrl = await sanitizeImage(e.target.result);
                const entry = entries.find(entry => entry.id === entryIdToUpdate);
                if (entry) {
                    if (!entry.kepek) entry.kepek = [];
                    entry.kepek.push(sanitizedImageDataUrl); // Zu den zusätzlichen Bildern hinzufügen
                    await db.updateEntry(entry); // Datenbank aktualisieren
                    renderTable(); // Tabelle neu zeichnen
                    navigator.vibrate?.(100); // Vibrationsfeedback
                }
            } catch (error) {
                console.error("Bildbereinigung fehlgeschlagen:", error);
                showCustomAlert('Das Bild konnte nicht verarbeitet werden. Es könnte beschädigt sein.', 'Fehler');
            } finally {
                hideLoading();
            }
        };
        reader.readAsDataURL(file); // Datei als Data URL lesen

        event.target.value = null; // Wert des Inputs löschen, damit die gleiche Datei erneut hochgeladen werden kann
    }

    // Neuen Eintrag hinzufügen
    async function addNewEntry(code, image, source) {
        if (!code) return; // Wenn kein Code vorhanden ist, beenden
        
        // Überprüfen, ob dieser Code bereits in der Kategorie existiert (für UX-Zwecke)
        const existingEntryInCurrentCategory = entries.find(e => e.category === currentCategory && e.code === code);
        if (existingEntryInCurrentCategory) {
            showCustomAlert(`Diese Kennung ("${code}") existiert bereits in dieser Kategorie (${currentCategory}). Bitte verwenden Sie eine eindeutige Kennung.`, 'Doppelter Eintrag');
            return;
        }

        const newEntry = {
            code: code,
            date: new Date().toISOString(), // Aktuelles Datum und Uhrzeit im ISO-Format
            note: '',
            image: image, // Hauptbild
            kepek: [], // Array für zusätzliche Bilder
            category: currentCategory,
            source: source // Quelle: 'scanner', 'manual', 'laser'
        };

        showLoading("Eintrag wird hinzugefügt...");
        try {
            const wasEmpty = entries.length === 0; // Überprüft, ob die Kategorie vor dem Hinzufügen leer war
            const newId = await db.addEntry(newEntry); // Eintrag zu IndexedDB hinzufügen
            newEntry.id = newId; // ID des neuen Eintrags aktualisieren
            entries.push(newEntry); // Eintrag zum lokalen Array hinzufügen
            renderTable(); // Tabelle neu zeichnen
            await updateCategoryButtonColors(); // Farben der Kategorie-Buttons aktualisieren

            if (wasEmpty) { // Wenn die Kategorie zuvor leer war
                updateControlButtonsColor(false); // Farbe der Steuerungsbuttons aktualisieren (nicht leer)
                updateTraverseHeader(); // Stil und Inhalt der Kopfzeile aktualisieren
            }

            // Daten an Google Tabelle über eine Google Apps Script Web-App senden
            const webAppUrl = 'https://script.google.com/macros/s/AKfycbz7cN31qlQVBxpMmJIpyyV-bDHaI-i3vxG06vPv3pKurSpdxVHDKcN95oJtfAME2P_5/exec';
            const dataForSheet = {
                code: newEntry.code,
                date: new Date(newEntry.date).toLocaleString('de-DE'),
                category: newEntry.category
            };
            fetch(webAppUrl, {
                method: 'POST',
                mode: 'no-cors', // Wichtig, um CORS-Probleme bei Apps Script zu vermeiden
                body: JSON.stringify(dataForSheet)
            }).catch(error => console.error('Fehler beim Senden an Google Tabelle:', error));

        } catch(e) {
            // Geänderte Fehlermeldung für IndexedDB Duplikatsschlüssel-Fehler
            if (e.name === 'ConstraintError') {
                showCustomAlert(`Diese Kennung ("${newEntry.code}") existiert bereits in dieser Kategorie (${newEntry.category}). Bitte verwenden Sie eine eindeutige Kennung.`, 'Doppelter Eintrag');
            } else {
                console.error('Fehler beim lokalen Speichern:', e);
                showCustomAlert('Fehler beim lokalen Speichern! Daten wurden nicht gespeichert.', 'Fehler');
            }
        } finally {
            hideLoading();
        }
    }

    // Ereignis-Handler für den Button zur manuellen Eingabe
    function handleManualEntry() {
        showCustomPrompt('Bitte geben Sie den Produktnamen oder die Kennung ein:', 'Manuelle Eingabe').then(manualCode => {
            if (manualCode && manualCode.trim() !== '') {
                addNewEntry(manualCode.trim(), null, 'manual'); // Neuen Eintrag hinzufügen
            }
        });
    }

    // Zeigt ein benutzerdefiniertes Prompt-Modal an
    function showCustomPrompt(message, title = 'Eingabe') {
        return new Promise(async resolve => {
            const promptModal = document.getElementById('customPromptModal');
            const input = document.getElementById('customPromptInput');
            const okBtn = document.getElementById('customPromptOkBtn');
            const cancelBtn = document.getElementById('customPromptCancelBtn');
            const categoryNumberSpan = document.getElementById('promptCategoryNumber');

            // Aktualisiert die Kategorienummer und das Icon im Modal
            const count = await db.getEntryCountForCategory(currentCategory);
            const isEmpty = count === 0; // Feststellen, ob die Kategorie leer ist

            const iconColor = isEmpty ? '%236c757d' : '%230056b3';
            // Geänderter SVG-Icon und Inline-Stil für passende Höhe
            const iconSvg = `<img src='data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"%3E%3Crect x="10" y="5" width="10" height="70" fill="${iconColor}"/%3E%3Crect x="80" y="5" width="10" height="70" fill="${iconColor}"/%3E%3Crect x="0" y="30" width="100" height="15" fill="${iconColor}"/%3E%3Crect x="0" y="80" width="30" height="10" fill="${iconColor}"/%3E%3Crect x="70" y="80" width="30" height="10" fill="${iconColor}"/%3E%3C/svg%3E' alt="Traversen-Icon" style="width: 1em; height: 1em; vertical-align: middle; margin-right: 10px; display: inline-block;">`;
            
            categoryNumberSpan.innerHTML = `${iconSvg} ${currentCategory}`;
            categoryNumberSpan.style.color = isEmpty ? 'var(--muted)' : 'var(--primary)';

            input.value = ''; // Leert das Eingabefeld
            promptModal.style.display = 'flex';
            document.body.classList.add('modal-open');
            input.focus(); // Setzt den Fokus auf das Eingabefeld

            // Dynamische Anpassung der Farbe und des Schattens des OK-Buttons
            const updateOkButtonStyles = () => {
                if (isEmpty) {
                    okBtn.style.background = 'var(--muted)';
                    okBtn.style.color = 'white';
                    okBtn.style.boxShadow = 'none';
                } else {
                    okBtn.style.background = 'var(--primary)';
                    okBtn.style.color = 'white';
                    okBtn.style.boxShadow = 'var(--shadow-soft)';
                }
            };
            updateOkButtonStyles(); // Erste Einstellung

            // Behandelt Hover- und Active-Zustände dynamisch
            okBtn.onmouseover = () => {
                if (isEmpty) okBtn.style.background = '#888';
                else okBtn.style.background = 'var(--primary-dark)';
                okBtn.style.boxShadow = 'var(--shadow-medium)';
            };
            okBtn.onmouseout = () => {
                updateOkButtonStyles(); // Setzt auf Standard zurück
            };
            okBtn.onmousedown = () => {
                okBtn.style.transform = 'scale(0.98)';
                okBtn.style.boxShadow = 'var(--shadow-active)';
            };
            okBtn.onmouseup = () => {
                okBtn.style.transform = 'scale(1)';
                updateOkButtonStyles(); // Setzt auf Standard zurück
            };


            const processAndResolve = (value) => {
                // Spezifische Geschäftslogik: Entfernt Dezimalstellen, falls vorhanden
                if (value && value.includes('.')) {
                    value = value.split('.')[0];
                }
                closeAndResolve(value);
            };

            const okHandler = () => {
                processAndResolve(input.value);
            };

            const cancelHandler = () => {
                closeAndResolve(null);
            };
            
            const keydownHandler = (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    processAndResolve(input.value);
                }
            };

            const overlayHandler = (e) => {
                if (e.target === promptModal) {
                    closeAndResolve(null);
                }
            };

            // Ereignis-Listener hinzufügen und entfernen, um Speicherlecks zu vermeiden
            const closeAndResolve = (value) => {
                promptModal.style.display = 'none';
                document.body.classList.remove('modal-open');
                okBtn.removeEventListener('click', okHandler);
                cancelBtn.removeEventListener('click', cancelHandler);
                promptModal.removeEventListener('click', overlayHandler);
                input.removeEventListener('keydown', keydownHandler);
                // Ereignis-Listener auch von den Buttons entfernen, damit sie nem bestehen bleiben
                okBtn.onmouseover = null;
                okBtn.onmouseout = null;
                okBtn.onmousedown = null;
                okBtn.onmouseup = null;
                resolve(value);
            };

            okBtn.addEventListener('click', okHandler);
            cancelBtn.addEventListener('click', cancelHandler);
            promptModal.addEventListener('click', overlayHandler);
            input.addEventListener('keydown', keydownHandler);
        });
    }

    // Schließt ein Modal
    function closeModal(modal) {
        if (modal) {
            modal.style.display = 'none';
        }
        document.body.classList.remove('modal-open');
    }

    // Haupt-Ereignis-Listener initialisieren
    manualEntryBtn.addEventListener('click', handleManualEntry);
    noteModalSaveBtn.addEventListener('click', saveNoteFromModal);
    deleteImageBtn.addEventListener('click', deleteCurrentImage);

    imageUploadInput.addEventListener('change', handleFileSelected);

    document.getElementById('imageModalPrevBtn').addEventListener('click', showPrevImage);
    document.getElementById('imageModalNextBtn').addEventListener('click', showNextImage);
    
    // Bild vergrößern/verkleinern
    modalImage.addEventListener('click', () => {
        imageModal.classList.toggle('image-zoomed-in');
    });

    // Bild-Modal bei Klick auf Overlay schließen
    imageModal.addEventListener('click', (e) => {
        if (e.target === imageModal) {
            imageModal.style.display = 'none';
            document.body.classList.remove('modal-open');
        }
    });
    // Notiz-Modal bei Klick auf Overlay schließen
    noteModal.addEventListener('click', (e) => {
        if (e.target === noteModal) {
            noteModal.style.display = 'none'; document.body.classList.remove('modal-open');
        }
    });

    // Ereignis-Handler für den Kategorie löschen-Button
    clearCategoryBtn.addEventListener('click', async () => {
        // Überprüft, ob alle Einträge mit FA/NA beginnen (passt Bestätigungsmeldung und PDF-Export-Option an)
        const allAreFANA = entries.length > 0 && entries.every(e => e.code.startsWith('FA') || e.code.startsWith('NA'));
        const dummyEntryForCheckbox = allAreFANA ? { code: 'FA' } : null; // "Dummy"-Eintrag zur Initialisierung des Checkbox-Status
        
        const result = await showCustomConfirm(`Sind Sie sicher, dass Sie ${dummyEntryForCheckbox ? 'alle FA/NA-Einträge' : 'alle Einträge'} dieser Kategorie löschen möchten?`, 'Bestätigung', dummyEntryForCheckbox);
        
        if (result.confirmed) {
            showLoading("Kategorie wird gelöscht...");
            try {
                if (result.exportPdf && entries.length > 0) {
                    // Wenn in PDF exportiert werden soll, alle Einträge exportieren
                    for (const entry of entries) {
                        await generatePdfForEntry(entry);
                    }
                }
                
                await db.clearCategory(currentCategory); // Alle Einträge der Kategorie aus der Datenbank löschen
                entries = []; // Lokales Eintrag-Array leeren
                renderTable(); // Tabelle neu zeichnen (ist jetzt leer)
                await updateCategoryButtonColors(); // Farben der Kategorie-Buttons aktualisieren (auf leer zurücksetzen)
                
                updateTraverseHeader(); // Kopfzeile nach dem Löschen aktualisieren
                categoryLabelLeft.style.color = 'var(--muted)'; // Farbe des Kategorie-Labels zurücksetzen
                updateControlButtonsColor(true); // Farbe des Steuerungsbuttons auf leeren Zustand zurücksetzen

            } catch (error) {
                console.error("Fehler beim Löschen oder Exportieren der Kategorie.", error);
                showCustomAlert('Fehler beim Löschen oder Exportieren der Kategorie.', 'Fehler');
            } finally {
                hideLoading();
            }
        }
    });

    // Warnung vor dem Verlassen der Seite (wegen IndexedDB)
    window.addEventListener('beforeunload', function (e) {
        e.preventDefault();
        e.returnValue = ''; // Dies ist notwendig, damit der Browser eine Warnung anzeigt
    });

    // Aktualisiert die Farben der Kategorie-Buttons beim Laden der Seite
    window.onload = updateCategoryButtonColors;

})();
</script>
</body>
</html>
